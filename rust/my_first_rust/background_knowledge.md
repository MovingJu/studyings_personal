# Why Immutable is faster than Mutable

프로그램이 동작될 때 안전성이 훼손되는 경우가, 한 메모리 영역을 여러 쓰레드 혹은 프로세스가 쓰기 경쟁을 하는 것이다. 

이런 경우 동시성 처리를 해줘야한다. 한 쓰레드가 쓸 때 다른 쓰레드가 기다리게 하던가 해야한다.

그런데, 만약 어떤 메모리 영역이 한번 선언되고 난 후에는 값이 변경되지 않는 다는 것이 보장된다면, 이러한 동시성 처리를 하지 않아도 된다. 

프로그램의 프로세스 관리가 편해지는 것이고, 안전성이 높아지는 것이다.

프로그램을 짜다 보면 예상보다 더 많이, 변수가 초깃값으로 지정되어 선언되고, 그 후로는 그 값이 변하지 않는 경우가 많다. 

Rust에서는 변수에 대해서 디폴트로 Read Only로 해 둠으로써, 불필요하게 동시성을 관리할 mut 형 변수가 많아지지 않게하려 한 것이다. 

정말로 초깃값을 다른 값으로 변경시키는게 필요한 변수만 let mut로 선언해서 사용하라는 것이다.

# Difference between const and just let in rust

- const로 선언한 상수는 전혀 변경할 수가 없다.

- 상수는 선언될 때 타입과 크기가 결정되어야 한다. 반면, 변수는 값만 주어저도 강제 타입추론에 의해 타입이 결정될 수 있다.

- 상수는 함수 밖에서 선언되어, 전체함수에서 사용 가능하나 변수는 그렇지 않다.

# usize가 있는 이유

32비트 컴퓨터 아키텍처라는 것은, CPU에서 사용하는 주소(Adress) 비트와 데이터 비트가 32비트라는 얘기다. 

주소 값을 나타낼 때 32비트, 데이터 공간을 나타낼 때도 32비트를 사용한다는 의미다. 따라서, 32비트 컴퓨터에서 32비트짜리 데이터를 읽는데는 한 번의 사이클로 가능하지만, 64비트짜리 데이터는 2번에 걸쳐 읽어야한다. 

따라서, 32비트 컴퓨터에서는 가능한 32비트 크기의 변수를 사용하는 것이 효율적이겠지만, 64비트에서는 64비트 크기 변수도 문제 없겠다.

이러한 이유로 큰 수에 대한 처리를 하는 BigInteger 같은 클래스를 만들 때, 수백개의 배열을 만들어서 수를 표현하고 연산을 하게되는데, 32비트 컴퓨터는 32비트형 변수로 배열을 만들고, 64비트 컴퓨터에서는 64비트형 변수로 배열을 만드는게 연산 속도를 높이는 중요한 요소이다.

이러한 경우 usize라는 변수를 사용하면, 프로그래머가 동작되는 컴퓨터의 아키텍처를 알아내서 u32로 할 지 u64로 할 지를 어렵게 결정하지 않아도되어 편리할 수 있다.

그 보다는 Rust에서 배열, 벡터(Vector)와 같은 컬렉션(Collection)의 크기를 알고자 할 때 .len()을 사용하게 되는데, 이 .len()이 리턴하는 값이 usize라는 점이 usize 타입 사용의 유용성을 얘기해준다.

이렇게 장황하게 usize에 대해 얘기하는 것은, 위와 같이 배열이나 벡터의 크기가 usize 타입이기 때문에, 어떤 양의 정수를 변수로 선언해야하고, **이 변수가 배열이나 벡터의 크기와 연산이 필요하다면 usize로 변수를 선언해서 사용하는 것이 u32보다 편하기 때문이다.**