# 복잡한 PL문법의 이유

클래스, 템플릿, 생성자 등 복잡한 언어의 문법들은 **재사용성**에 기인한다.

객체지향프로그래밍 언어는 데이터와 이를 가공하는 함수를 매우 밀접하게 붙인다.

그래서 오류의 가능성을 줄이고, 유지 및 보수를 용이하게 함이 목적이다.

이는 **재사용성**을 높이면 자동으로 해결된다. 코드의 재사용성을 높이고 재사용하려 노력하자.

# 소프트웨어란

**데이터와 이를 조작하는 함수(기능)로 구성됨.**

이를 cpp에선 구조체와 함수로 다룰 수도 있겠지만, 한번에 처리하기 위해 **클래스**를 사용하자.

구조체와 함수로 구현된건 *느슨하게 결합된 구조* 라 한다.

하지만 구조체는 데이터 구조의 변경이 생기면 구조체와 함수 전체의 수정을 요구한다.

또한, 재사용되는 경우에 이를 그대로 쓰는 경우가 드물기 때문에 재사용할 때마다 복잡한 수정과정을 거친다.

# C++를 쓰는 이유

성능의 요소도 있지만, **메모리에 직접 접근 가능**한 이점이 있다.

그리고, **객체 지향 문법의 모든 요소**를 다 다룰 수 있다.

라이브러리 지원이 적고, 사용자에게 많은 부담이 가해져서 여러 에러가 발생할 수 있음은 사실이다.

하지만, 개발보다는 **연구에 초점이 맞춰져 있는 언어**라 생각하자.

개발을 하더라도 더 고급 언어의 부분부분 쓰이는 성능 라이브러리처럼 활용하자.

# Class 사용 원칙

다음은 클래스를 사용하며 지켜야할 **기본 원칙**이다.

이것도 못지키면 클래스를 쓰는 이유가 없으므로 꼭 지키도록 하자.

## Encapsulation

클래스의 멤버 변수와 멤버 함수를 밀접하게 결합한다.

변수와 함수가 떨어져 있는 구조체는 문제가 많다.

변수(데이터)와 함수(기능)이 최대한 밀접하게 붙어 있어야만 하고, 외부의 데이터에 의존해선 안됨!!

그래야 이후 클래스를 사용하는 곳이 늘어나더라도 클래스만 수정하면 모든 곳에 에러 없이 잘 작동할 것이다.

## Information Hiding

외부에서 클래스 내부를 알 필요가 없다. 

외부에서 클래스 내부를 알지 못할 수록 좋고, 특정 인터페이스(외부에서 내부에 접근하는 수단)로만 접근할 수 있을 수록 *독립성* 이 강하다고 한다.

독립성이 강한 클래스는 당장 다른 곳에서 재활용하기가 좋다.

그리고 내부를 수정하더라도 다른 곳을 건들 필요가 없기에 유지/보수 또한 탁월하다.

**private로 도배하자.**

그리고 protect를 지향하는데, public은 진짜 줄여야 한다.

public을 쓰는 경우가 제한되어 있을 정도이다.

### 생성자, 소멸자, 접근자의 경우 드러낸다.

특히 소멸자를 숨기면 아예 사용이 불가능하다.

접근자(set_, get_)은 값을 전달하는 것이므로, 내부를 수정하더라도 외부에서 고칠일이 없다!

### 멤버변수는 무조건 숨기자.

그래야 내부를 고칠 수 있지.

# 헤더파일과 파일의 분할

declaration/better.h
declaration/better.cpp 처럼

멤버 변수 및 멤버 함수의 선언과 구현을 따로 할 수 있다.

프로젝트가 커지면 좋음.

inline의 경우 함수 호출이 아니라 컴파일러가 해당 함수를 선언한 곳에 코드를 복붙하는 원리임.

그래서 선언한 곳과 다른 파일에 inline을 쓰면 linking 에러가 발생함.

\#include "~~"를 할 때마다 저 파일이 복사되고 다시 컴파일 되는 경우가 생기는데, 그때 ifndef, define, endif를 이용해서 막는다.